TODO:
-----


introduce a new harness based on JVMTI - measure # times a method has been invoked (for a start)
check if regression detection works for time based tests
transition to sbt

I've taken a look at the code. Good work overall. Here are a couple of comments:


2)
When using `Either` in BenchmarkRunner.run it can become unclear what the results can be. A better solution is to use
 a BenchmarkResult base class with to subclasses - 1 for success, 1 for failure:
abstract class Result
case class Success extends Result
case class Failure(s: String) extends Result


3)
In BenchmarkRunner.run you have a lot of if-then statements. You should convert them into pattern-match clauses, 
  or use an abstract base class for a BenchmarkType, 
  and then just run the appropriate method from there to perform the test.

4)
Is it possible to specify multiple files (benchmarks) in the console when starting the suite?

6)
Avoid:
a) extending collection classes (Persistor for example)
b) having getters and setters for fields which could have been set through a ctor (location in Persistor).

A better approach is to have _something_ like this:

trait Persistor {
  def loadResults(name: String): ArrayBuffer[BenchmarkResult]
  def saveResults(name: String, results: ArrayBuffer[BenchmarkResult])
}

class SimplePersistor extends Persistor {
  def loadResults(name: String): ArrayBuffer[BenchmarkResult] = { // read from file `name` and create the arraybuffer }
  def saveResults(name: String, results: ArrayBuffer[BenchmarkResult]) { // write to file }
}

7)
Avoid having global getters and setters - Statistic has alpha, but this should be a ctor parameter.

8)
Factor out interfaces (traits) wherever possible - for instance Log should be a trait. 
A ConsoleLog should be one of the implementations. 
Same thing for Report - Report should be a trait, and a SimpleLogReport should be one implementation.
+The same comment as above - `logLevel` should be a ctor argument.


DONE:
-----

Format the code
Change the style - no capital names, meaningful variable names
Indent the code - 2 spaces instead of a TAB
Try to unify the Harness and Regression
Avoid using member fields where local variables or method parameters are needed
Add Config phase and Config objects
Add Persistor abstraction
Add Logger abstraction
Change the encoding to UTF-8
Generate the files that contain old results into a subdir `tmp`, not a top-level directory
Remove the `bin` directory from the repository
Add other stuff from your notes here

5)
The main package can be scala.tools.sbs

1)
--> it's considered bad style to have global variables as in the case of the package object with 
  config, log and benchmark
--> instead: every module depending on the config, log and benchmark should take these objects 
  as arguments to its constructor
    --> for example, BenchmarkRunner should not be a singleton object - instead it should be a class 
      with a ctor parameter `config`
    --> that way you ensure that whenever the BenchmarkRunner is used, the config will be ready for it 
      (its dependency on someone having to create a `config` and set it globally is not hardcoded)




